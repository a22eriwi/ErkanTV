{"ast":null,"code":"const metadataCache = useRef({}); // ðŸ§  in-memory cache\n\nuseEffect(() => {\n  const fetchSeries = async () => {\n    const token = localStorage.getItem('token');\n    try {\n      const res = await fetch(`${API_URL}/api/series`, {\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      const folders = await res.json();\n      const seriesWithMetadata = await Promise.all(folders.map(async folder => {\n        // Use cache if available\n        if (metadataCache.current[folder]) {\n          return {\n            folder,\n            ...metadataCache.current[folder]\n          };\n        }\n\n        // Otherwise fetch from API\n        const metaRes = await fetch(`${API_URL}/api/metadata/${encodeURIComponent(folder)}`);\n        const metaData = await metaRes.json();\n        const metadata = {\n          poster: metaData.Poster && metaData.Poster !== 'N/A' ? metaData.Poster : null,\n          title: folder,\n          imdbRating: metaData.imdbRating || 'N/A',\n          genre: metaData.Genre || ''\n        };\n        metadataCache.current[folder] = metadata; // âœ… Save to cache\n\n        return {\n          folder,\n          ...metadata\n        };\n      }));\n      setSeriesList(seriesWithMetadata);\n      const allGenres = seriesWithMetadata.flatMap(series => series.genre.split(',').map(g => g.trim()));\n      setGenres([...new Set(allGenres)]);\n    } catch (err) {\n      console.error('Error fetching series folders or metadata:', err);\n    }\n  };\n  fetchSeries();\n}, []);","map":{"version":3,"names":["metadataCache","useRef","useEffect","fetchSeries","token","localStorage","getItem","res","fetch","API_URL","headers","Authorization","folders","json","seriesWithMetadata","Promise","all","map","folder","current","metaRes","encodeURIComponent","metaData","metadata","poster","Poster","title","imdbRating","genre","Genre","setSeriesList","allGenres","flatMap","series","split","g","trim","setGenres","Set","err","console","error"],"sources":["D:/Erkflix/src/SeriesRow.js"],"sourcesContent":["const metadataCache = useRef({}); // ðŸ§  in-memory cache\r\n\r\nuseEffect(() => {\r\n    const fetchSeries = async () => {\r\n        const token = localStorage.getItem('token');\r\n        try {\r\n            const res = await fetch(`${API_URL}/api/series`, {\r\n                headers: { Authorization: `Bearer ${token}` },\r\n            });\r\n            const folders = await res.json();\r\n\r\n            const seriesWithMetadata = await Promise.all(\r\n                folders.map(async (folder) => {\r\n                    // Use cache if available\r\n                    if (metadataCache.current[folder]) {\r\n                        return {\r\n                            folder,\r\n                            ...metadataCache.current[folder],\r\n                        };\r\n                    }\r\n\r\n                    // Otherwise fetch from API\r\n                    const metaRes = await fetch(`${API_URL}/api/metadata/${encodeURIComponent(folder)}`);\r\n                    const metaData = await metaRes.json();\r\n\r\n                    const metadata = {\r\n                        poster: metaData.Poster && metaData.Poster !== 'N/A' ? metaData.Poster : null,\r\n                        title: folder,\r\n                        imdbRating: metaData.imdbRating || 'N/A',\r\n                        genre: metaData.Genre || '',\r\n                    };\r\n\r\n                    metadataCache.current[folder] = metadata; // âœ… Save to cache\r\n\r\n                    return {\r\n                        folder,\r\n                        ...metadata,\r\n                    };\r\n                })\r\n            );\r\n\r\n            setSeriesList(seriesWithMetadata);\r\n\r\n            const allGenres = seriesWithMetadata.flatMap(series =>\r\n                series.genre.split(',').map(g => g.trim())\r\n            );\r\n            setGenres([...new Set(allGenres)]);\r\n        } catch (err) {\r\n            console.error('Error fetching series folders or metadata:', err);\r\n        }\r\n    };\r\n\r\n    fetchSeries();\r\n}, []);\r\n"],"mappings":"AAAA,MAAMA,aAAa,GAAGC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;AAElCC,SAAS,CAAC,MAAM;EACZ,MAAMC,WAAW,GAAG,MAAAA,CAAA,KAAY;IAC5B,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI;MACA,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAAC,GAAGC,OAAO,aAAa,EAAE;QAC7CC,OAAO,EAAE;UAAEC,aAAa,EAAE,UAAUP,KAAK;QAAG;MAChD,CAAC,CAAC;MACF,MAAMQ,OAAO,GAAG,MAAML,GAAG,CAACM,IAAI,CAAC,CAAC;MAEhC,MAAMC,kBAAkB,GAAG,MAAMC,OAAO,CAACC,GAAG,CACxCJ,OAAO,CAACK,GAAG,CAAC,MAAOC,MAAM,IAAK;QAC1B;QACA,IAAIlB,aAAa,CAACmB,OAAO,CAACD,MAAM,CAAC,EAAE;UAC/B,OAAO;YACHA,MAAM;YACN,GAAGlB,aAAa,CAACmB,OAAO,CAACD,MAAM;UACnC,CAAC;QACL;;QAEA;QACA,MAAME,OAAO,GAAG,MAAMZ,KAAK,CAAC,GAAGC,OAAO,iBAAiBY,kBAAkB,CAACH,MAAM,CAAC,EAAE,CAAC;QACpF,MAAMI,QAAQ,GAAG,MAAMF,OAAO,CAACP,IAAI,CAAC,CAAC;QAErC,MAAMU,QAAQ,GAAG;UACbC,MAAM,EAAEF,QAAQ,CAACG,MAAM,IAAIH,QAAQ,CAACG,MAAM,KAAK,KAAK,GAAGH,QAAQ,CAACG,MAAM,GAAG,IAAI;UAC7EC,KAAK,EAAER,MAAM;UACbS,UAAU,EAAEL,QAAQ,CAACK,UAAU,IAAI,KAAK;UACxCC,KAAK,EAAEN,QAAQ,CAACO,KAAK,IAAI;QAC7B,CAAC;QAED7B,aAAa,CAACmB,OAAO,CAACD,MAAM,CAAC,GAAGK,QAAQ,CAAC,CAAC;;QAE1C,OAAO;UACHL,MAAM;UACN,GAAGK;QACP,CAAC;MACL,CAAC,CACL,CAAC;MAEDO,aAAa,CAAChB,kBAAkB,CAAC;MAEjC,MAAMiB,SAAS,GAAGjB,kBAAkB,CAACkB,OAAO,CAACC,MAAM,IAC/CA,MAAM,CAACL,KAAK,CAACM,KAAK,CAAC,GAAG,CAAC,CAACjB,GAAG,CAACkB,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAAC,CAC7C,CAAC;MACDC,SAAS,CAAC,CAAC,GAAG,IAAIC,GAAG,CAACP,SAAS,CAAC,CAAC,CAAC;IACtC,CAAC,CAAC,OAAOQ,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,4CAA4C,EAAEF,GAAG,CAAC;IACpE;EACJ,CAAC;EAEDpC,WAAW,CAAC,CAAC;AACjB,CAAC,EAAE,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}